/** \file
 *  This C source file was generated by $ANTLR version 3.5.3
 *
 *     -  From the grammar source file : AwesomeLang.g
 *     -                            On : 2024-10-06 02:39:10
 *     -                for the parser : AwesomeLangParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "AwesomeLangParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pAwesomeLangParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pAwesomeLangParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pAwesomeLangParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pAwesomeLangParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   AwesomeLangParserTokenNames[51+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "BITS",
        (pANTLR3_UINT8) "BOOL",
        (pANTLR3_UINT8) "CHAR",
        (pANTLR3_UINT8) "DEC",
        (pANTLR3_UINT8) "HEX",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'%'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'..'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'<='",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'>='",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'^'",
        (pANTLR3_UINT8) "'and'",
        (pANTLR3_UINT8) "'array'",
        (pANTLR3_UINT8) "'begin'",
        (pANTLR3_UINT8) "'bool'",
        (pANTLR3_UINT8) "'break'",
        (pANTLR3_UINT8) "'byte'",
        (pANTLR3_UINT8) "'char'",
        (pANTLR3_UINT8) "'def'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'end'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'int'",
        (pANTLR3_UINT8) "'long'",
        (pANTLR3_UINT8) "'of'",
        (pANTLR3_UINT8) "'or'",
        (pANTLR3_UINT8) "'repeat'",
        (pANTLR3_UINT8) "'string'",
        (pANTLR3_UINT8) "'then'",
        (pANTLR3_UINT8) "'uint'",
        (pANTLR3_UINT8) "'ulong'",
        (pANTLR3_UINT8) "'until'",
        (pANTLR3_UINT8) "'while'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 void
	list    (pAwesomeLangParser ctx);
static 
 void
	item    (pAwesomeLangParser ctx);
static 
 void
	binOp    (pAwesomeLangParser ctx);
static 
 void
	unOp    (pAwesomeLangParser ctx);
static 
 void
	typeRef    (pAwesomeLangParser ctx);
static 
 void
	builtin    (pAwesomeLangParser ctx);
static 
 void
	arrayType    (pAwesomeLangParser ctx);
static 
 void
	funcSignature    (pAwesomeLangParser ctx);
static 
 void
	sourceItem    (pAwesomeLangParser ctx);
static 
 void
	funcDef    (pAwesomeLangParser ctx);
static 
 void
	expr    (pAwesomeLangParser ctx);
static 
 void
	primaryExpr    (pAwesomeLangParser ctx);
static 
 void
	sliceExpr    (pAwesomeLangParser ctx);
static 
 void
	callExpr    (pAwesomeLangParser ctx);
static 
 void
	literal    (pAwesomeLangParser ctx);
static 
 void
	range    (pAwesomeLangParser ctx);
static 
 void
	rangeList    (pAwesomeLangParser ctx);
static 
 void
	statement    (pAwesomeLangParser ctx);
static 
 void
	ifStatement    (pAwesomeLangParser ctx);
static 
 void
	elseStatement    (pAwesomeLangParser ctx);
static 
 void
	loopStatement    (pAwesomeLangParser ctx);
static 
 void
	repeatStatement    (pAwesomeLangParser ctx);
static 
 void
	breakStatement    (pAwesomeLangParser ctx);
static 
 void
	expressionStatement    (pAwesomeLangParser ctx);
static 
 void
	blockStatement    (pAwesomeLangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred30_AwesomeLang    (pAwesomeLangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred33_AwesomeLang    (pAwesomeLangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred34_AwesomeLang    (pAwesomeLangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred47_AwesomeLang    (pAwesomeLangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred50_AwesomeLang    (pAwesomeLangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred51_AwesomeLang    (pAwesomeLangParser ctx);
static void	AwesomeLangParserFree(pAwesomeLangParser ctx);
static void     AwesomeLangParserReset (pAwesomeLangParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "AwesomeLang.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new AwesomeLangParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pAwesomeLangParser
AwesomeLangParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return AwesomeLangParserNewSSD(instream, NULL);
}

/** \brief Create a new AwesomeLangParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pAwesomeLangParser
AwesomeLangParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pAwesomeLangParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pAwesomeLangParser) ANTLR3_CALLOC(1, sizeof(AwesomeLangParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in AwesomeLangParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our AwesomeLangParser interface
     */
    ctx->list	= list;
    ctx->item	= item;
    ctx->binOp	= binOp;
    ctx->unOp	= unOp;
    ctx->typeRef	= typeRef;
    ctx->builtin	= builtin;
    ctx->arrayType	= arrayType;
    ctx->funcSignature	= funcSignature;
    ctx->sourceItem	= sourceItem;
    ctx->funcDef	= funcDef;
    ctx->expr	= expr;
    ctx->primaryExpr	= primaryExpr;
    ctx->sliceExpr	= sliceExpr;
    ctx->callExpr	= callExpr;
    ctx->literal	= literal;
    ctx->range	= range;
    ctx->rangeList	= rangeList;
    ctx->statement	= statement;
    ctx->ifStatement	= ifStatement;
    ctx->elseStatement	= elseStatement;
    ctx->loopStatement	= loopStatement;
    ctx->repeatStatement	= repeatStatement;
    ctx->breakStatement	= breakStatement;
    ctx->expressionStatement	= expressionStatement;
    ctx->blockStatement	= blockStatement;
    ctx->synpred30_AwesomeLang	= synpred30_AwesomeLang;
    ctx->synpred33_AwesomeLang	= synpred33_AwesomeLang;
    ctx->synpred34_AwesomeLang	= synpred34_AwesomeLang;
    ctx->synpred47_AwesomeLang	= synpred47_AwesomeLang;
    ctx->synpred50_AwesomeLang	= synpred50_AwesomeLang;
    ctx->synpred51_AwesomeLang	= synpred51_AwesomeLang;
    ctx->free			= AwesomeLangParserFree;
    ctx->reset			= AwesomeLangParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = AwesomeLangParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
AwesomeLangParserReset (pAwesomeLangParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 AwesomeLangParserFree(pAwesomeLangParser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return AwesomeLangParserTokenNames;
}


/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_item_in_list299  */
static	ANTLR3_BITWORD FOLLOW_item_in_list299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_item_in_list299	= { FOLLOW_item_in_list299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_list302  */
static	ANTLR3_BITWORD FOLLOW_18_in_list302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_list302	= { FOLLOW_18_in_list302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_item_in_list304  */
static	ANTLR3_BITWORD FOLLOW_item_in_list304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_item_in_list304	= { FOLLOW_item_in_list304_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_item326  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_item326_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_item326	= { FOLLOW_IDENTIFIER_in_item326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_item329  */
static	ANTLR3_BITWORD FOLLOW_44_in_item329_bits[]	= { ANTLR3_UINT64_LIT(0x00068C3400000200) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_item329	= { FOLLOW_44_in_item329_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRef_in_item331  */
static	ANTLR3_BITWORD FOLLOW_typeRef_in_item331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeRef_in_item331	= { FOLLOW_typeRef_in_item331_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtin_in_typeRef453  */
static	ANTLR3_BITWORD FOLLOW_builtin_in_typeRef453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_builtin_in_typeRef453	= { FOLLOW_builtin_in_typeRef453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_typeRef461  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_typeRef461_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_typeRef461	= { FOLLOW_IDENTIFIER_in_typeRef461_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arrayType_in_typeRef469  */
static	ANTLR3_BITWORD FOLLOW_arrayType_in_typeRef469_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_arrayType_in_typeRef469	= { FOLLOW_arrayType_in_typeRef469_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtin_in_arrayType534  */
static	ANTLR3_BITWORD FOLLOW_builtin_in_arrayType534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_builtin_in_arrayType534	= { FOLLOW_builtin_in_arrayType534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_arrayType538  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_arrayType538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_arrayType538	= { FOLLOW_IDENTIFIER_in_arrayType538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_arrayType541  */
static	ANTLR3_BITWORD FOLLOW_32_in_arrayType541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_arrayType541	= { FOLLOW_32_in_arrayType541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_arrayType543  */
static	ANTLR3_BITWORD FOLLOW_28_in_arrayType543_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_arrayType543	= { FOLLOW_28_in_arrayType543_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEC_in_arrayType545  */
static	ANTLR3_BITWORD FOLLOW_DEC_in_arrayType545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEC_in_arrayType545	= { FOLLOW_DEC_in_arrayType545_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_arrayType547  */
static	ANTLR3_BITWORD FOLLOW_29_in_arrayType547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_arrayType547	= { FOLLOW_29_in_arrayType547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_funcSignature565  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_funcSignature565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_funcSignature565	= { FOLLOW_IDENTIFIER_in_funcSignature565_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_funcSignature567  */
static	ANTLR3_BITWORD FOLLOW_14_in_funcSignature567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008200) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_funcSignature567	= { FOLLOW_14_in_funcSignature567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_in_funcSignature569  */
static	ANTLR3_BITWORD FOLLOW_list_in_funcSignature569_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_in_funcSignature569	= { FOLLOW_list_in_funcSignature569_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_funcSignature571  */
static	ANTLR3_BITWORD FOLLOW_15_in_funcSignature571_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_funcSignature571	= { FOLLOW_15_in_funcSignature571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_funcSignature574  */
static	ANTLR3_BITWORD FOLLOW_44_in_funcSignature574_bits[]	= { ANTLR3_UINT64_LIT(0x00068C3400000200) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_funcSignature574	= { FOLLOW_44_in_funcSignature574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRef_in_funcSignature576  */
static	ANTLR3_BITWORD FOLLOW_typeRef_in_funcSignature576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeRef_in_funcSignature576	= { FOLLOW_typeRef_in_funcSignature576_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_funcDef_in_sourceItem596  */
static	ANTLR3_BITWORD FOLLOW_funcDef_in_sourceItem596_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_funcDef_in_sourceItem596	= { FOLLOW_funcDef_in_sourceItem596_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_funcDef614  */
static	ANTLR3_BITWORD FOLLOW_38_in_funcDef614_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_funcDef614	= { FOLLOW_38_in_funcDef614_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_funcSignature_in_funcDef616  */
static	ANTLR3_BITWORD FOLLOW_funcSignature_in_funcDef616_bits[]	= { ANTLR3_UINT64_LIT(0x0038430A00084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_funcSignature_in_funcDef616	= { FOLLOW_funcSignature_in_funcDef616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_funcDef618  */
static	ANTLR3_BITWORD FOLLOW_statement_in_funcDef618_bits[]	= { ANTLR3_UINT64_LIT(0x0038430A00084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_funcDef618	= { FOLLOW_statement_in_funcDef618_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_funcDef621  */
static	ANTLR3_BITWORD FOLLOW_40_in_funcDef621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_funcDef621	= { FOLLOW_40_in_funcDef621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_primaryExpr_in_expr639  */
static	ANTLR3_BITWORD FOLLOW_primaryExpr_in_expr639_bits[]	= { ANTLR3_UINT64_LIT(0x00002000CFAB3002) };
static  ANTLR3_BITSET_LIST FOLLOW_primaryExpr_in_expr639	= { FOLLOW_primaryExpr_in_expr639_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binOp_in_expr642  */
static	ANTLR3_BITWORD FOLLOW_binOp_in_expr642_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_binOp_in_expr642	= { FOLLOW_binOp_in_expr642_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_primaryExpr_in_expr644  */
static	ANTLR3_BITWORD FOLLOW_primaryExpr_in_expr644_bits[]	= { ANTLR3_UINT64_LIT(0x00002000CFAB3002) };
static  ANTLR3_BITSET_LIST FOLLOW_primaryExpr_in_expr644	= { FOLLOW_primaryExpr_in_expr644_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unOp_in_primaryExpr664  */
static	ANTLR3_BITWORD FOLLOW_unOp_in_primaryExpr664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_unOp_in_primaryExpr664	= { FOLLOW_unOp_in_primaryExpr664_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_primaryExpr_in_primaryExpr666  */
static	ANTLR3_BITWORD FOLLOW_primaryExpr_in_primaryExpr666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_primaryExpr_in_primaryExpr666	= { FOLLOW_primaryExpr_in_primaryExpr666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_primaryExpr674  */
static	ANTLR3_BITWORD FOLLOW_14_in_primaryExpr674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_primaryExpr674	= { FOLLOW_14_in_primaryExpr674_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_primaryExpr676  */
static	ANTLR3_BITWORD FOLLOW_expr_in_primaryExpr676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_primaryExpr676	= { FOLLOW_expr_in_primaryExpr676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_primaryExpr678  */
static	ANTLR3_BITWORD FOLLOW_15_in_primaryExpr678_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_primaryExpr678	= { FOLLOW_15_in_primaryExpr678_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_primaryExpr686  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_primaryExpr686_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_primaryExpr686	= { FOLLOW_IDENTIFIER_in_primaryExpr686_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_primaryExpr688  */
static	ANTLR3_BITWORD FOLLOW_14_in_primaryExpr688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008200) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_primaryExpr688	= { FOLLOW_14_in_primaryExpr688_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_in_primaryExpr690  */
static	ANTLR3_BITWORD FOLLOW_list_in_primaryExpr690_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_in_primaryExpr690	= { FOLLOW_list_in_primaryExpr690_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_primaryExpr692  */
static	ANTLR3_BITWORD FOLLOW_15_in_primaryExpr692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_primaryExpr692	= { FOLLOW_15_in_primaryExpr692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_primaryExpr700  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_primaryExpr700_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_primaryExpr700	= { FOLLOW_IDENTIFIER_in_primaryExpr700_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_primaryExpr708  */
static	ANTLR3_BITWORD FOLLOW_literal_in_primaryExpr708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_primaryExpr708	= { FOLLOW_literal_in_primaryExpr708_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_primaryExpr_in_sliceExpr728  */
static	ANTLR3_BITWORD FOLLOW_primaryExpr_in_sliceExpr728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_primaryExpr_in_sliceExpr728	= { FOLLOW_primaryExpr_in_sliceExpr728_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_sliceExpr730  */
static	ANTLR3_BITWORD FOLLOW_28_in_sliceExpr730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_sliceExpr730	= { FOLLOW_28_in_sliceExpr730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rangeList_in_sliceExpr732  */
static	ANTLR3_BITWORD FOLLOW_rangeList_in_sliceExpr732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_rangeList_in_sliceExpr732	= { FOLLOW_rangeList_in_sliceExpr732_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_sliceExpr734  */
static	ANTLR3_BITWORD FOLLOW_29_in_sliceExpr734_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_sliceExpr734	= { FOLLOW_29_in_sliceExpr734_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_callExpr751  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_callExpr751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_callExpr751	= { FOLLOW_IDENTIFIER_in_callExpr751_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_callExpr753  */
static	ANTLR3_BITWORD FOLLOW_14_in_callExpr753_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008200) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_callExpr753	= { FOLLOW_14_in_callExpr753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_in_callExpr755  */
static	ANTLR3_BITWORD FOLLOW_list_in_callExpr755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_in_callExpr755	= { FOLLOW_list_in_callExpr755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_callExpr757  */
static	ANTLR3_BITWORD FOLLOW_15_in_callExpr757_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_callExpr757	= { FOLLOW_15_in_callExpr757_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_range833  */
static	ANTLR3_BITWORD FOLLOW_expr_in_range833_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_range833	= { FOLLOW_expr_in_range833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_20_in_range836  */
static	ANTLR3_BITWORD FOLLOW_20_in_range836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_20_in_range836	= { FOLLOW_20_in_range836_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_range838  */
static	ANTLR3_BITWORD FOLLOW_expr_in_range838_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_range838	= { FOLLOW_expr_in_range838_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_range_in_rangeList858  */
static	ANTLR3_BITWORD FOLLOW_range_in_rangeList858_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_range_in_rangeList858	= { FOLLOW_range_in_rangeList858_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_rangeList861  */
static	ANTLR3_BITWORD FOLLOW_18_in_rangeList861_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_rangeList861	= { FOLLOW_18_in_rangeList861_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_range_in_rangeList863  */
static	ANTLR3_BITWORD FOLLOW_range_in_rangeList863_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_range_in_rangeList863	= { FOLLOW_range_in_rangeList863_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_statement883  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_statement883_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_statement883	= { FOLLOW_ifStatement_in_statement883_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_loopStatement_in_statement891  */
static	ANTLR3_BITWORD FOLLOW_loopStatement_in_statement891_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_loopStatement_in_statement891	= { FOLLOW_loopStatement_in_statement891_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_repeatStatement_in_statement899  */
static	ANTLR3_BITWORD FOLLOW_repeatStatement_in_statement899_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_repeatStatement_in_statement899	= { FOLLOW_repeatStatement_in_statement899_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_breakStatement_in_statement907  */
static	ANTLR3_BITWORD FOLLOW_breakStatement_in_statement907_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_breakStatement_in_statement907	= { FOLLOW_breakStatement_in_statement907_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expressionStatement_in_statement915  */
static	ANTLR3_BITWORD FOLLOW_expressionStatement_in_statement915_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expressionStatement_in_statement915	= { FOLLOW_expressionStatement_in_statement915_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_blockStatement_in_statement923  */
static	ANTLR3_BITWORD FOLLOW_blockStatement_in_statement923_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_blockStatement_in_statement923	= { FOLLOW_blockStatement_in_statement923_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_ifStatement941  */
static	ANTLR3_BITWORD FOLLOW_41_in_ifStatement941_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_ifStatement941	= { FOLLOW_41_in_ifStatement941_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_ifStatement943  */
static	ANTLR3_BITWORD FOLLOW_expr_in_ifStatement943_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_ifStatement943	= { FOLLOW_expr_in_ifStatement943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_ifStatement945  */
static	ANTLR3_BITWORD FOLLOW_48_in_ifStatement945_bits[]	= { ANTLR3_UINT64_LIT(0x0038420A00084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_ifStatement945	= { FOLLOW_48_in_ifStatement945_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement947  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement947_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement947	= { FOLLOW_statement_in_ifStatement947_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elseStatement_in_ifStatement950  */
static	ANTLR3_BITWORD FOLLOW_elseStatement_in_ifStatement950_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_elseStatement_in_ifStatement950	= { FOLLOW_elseStatement_in_ifStatement950_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_elseStatement970  */
static	ANTLR3_BITWORD FOLLOW_39_in_elseStatement970_bits[]	= { ANTLR3_UINT64_LIT(0x0038420A00084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_elseStatement970	= { FOLLOW_39_in_elseStatement970_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_elseStatement972  */
static	ANTLR3_BITWORD FOLLOW_statement_in_elseStatement972_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_elseStatement972	= { FOLLOW_statement_in_elseStatement972_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_loopStatement990  */
static	ANTLR3_BITWORD FOLLOW_set_in_loopStatement990_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_loopStatement990	= { FOLLOW_set_in_loopStatement990_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_loopStatement998  */
static	ANTLR3_BITWORD FOLLOW_expr_in_loopStatement998_bits[]	= { ANTLR3_UINT64_LIT(0x0038430A00084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_loopStatement998	= { FOLLOW_expr_in_loopStatement998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_loopStatement1000  */
static	ANTLR3_BITWORD FOLLOW_statement_in_loopStatement1000_bits[]	= { ANTLR3_UINT64_LIT(0x0038430A00084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_loopStatement1000	= { FOLLOW_statement_in_loopStatement1000_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_loopStatement1003  */
static	ANTLR3_BITWORD FOLLOW_40_in_loopStatement1003_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_loopStatement1003	= { FOLLOW_40_in_loopStatement1003_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_repeatStatement1021  */
static	ANTLR3_BITWORD FOLLOW_46_in_repeatStatement1021_bits[]	= { ANTLR3_UINT64_LIT(0x0038420A00084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_repeatStatement1021	= { FOLLOW_46_in_repeatStatement1021_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_repeatStatement1024  */
static	ANTLR3_BITWORD FOLLOW_statement_in_repeatStatement1024_bits[]	= { ANTLR3_UINT64_LIT(0x0038420A00084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_repeatStatement1024	= { FOLLOW_statement_in_repeatStatement1024_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_repeatStatement1029  */
static	ANTLR3_BITWORD FOLLOW_set_in_repeatStatement1029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_repeatStatement1029	= { FOLLOW_set_in_repeatStatement1029_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_repeatStatement1037  */
static	ANTLR3_BITWORD FOLLOW_expr_in_repeatStatement1037_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_repeatStatement1037	= { FOLLOW_expr_in_repeatStatement1037_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_repeatStatement1039  */
static	ANTLR3_BITWORD FOLLOW_22_in_repeatStatement1039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_repeatStatement1039	= { FOLLOW_22_in_repeatStatement1039_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_breakStatement1057  */
static	ANTLR3_BITWORD FOLLOW_35_in_breakStatement1057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_breakStatement1057	= { FOLLOW_35_in_breakStatement1057_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_breakStatement1059  */
static	ANTLR3_BITWORD FOLLOW_22_in_breakStatement1059_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_breakStatement1059	= { FOLLOW_22_in_breakStatement1059_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expressionStatement1077  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expressionStatement1077_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expressionStatement1077	= { FOLLOW_expr_in_expressionStatement1077_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_expressionStatement1079  */
static	ANTLR3_BITWORD FOLLOW_22_in_expressionStatement1079_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_expressionStatement1079	= { FOLLOW_22_in_expressionStatement1079_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_blockStatement1097  */
static	ANTLR3_BITWORD FOLLOW_set_in_blockStatement1097_bits[]	= { ANTLR3_UINT64_LIT(0x0078434A00084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_blockStatement1097	= { FOLLOW_set_in_blockStatement1097_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_blockStatement1106  */
static	ANTLR3_BITWORD FOLLOW_statement_in_blockStatement1106_bits[]	= { ANTLR3_UINT64_LIT(0x0078434A00084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_blockStatement1106	= { FOLLOW_statement_in_blockStatement1106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sourceItem_in_blockStatement1110  */
static	ANTLR3_BITWORD FOLLOW_sourceItem_in_blockStatement1110_bits[]	= { ANTLR3_UINT64_LIT(0x0078434A00084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_sourceItem_in_blockStatement1110	= { FOLLOW_sourceItem_in_blockStatement1110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_blockStatement1114  */
static	ANTLR3_BITWORD FOLLOW_set_in_blockStatement1114_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_blockStatement1114	= { FOLLOW_set_in_blockStatement1114_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_binOp_in_synpred30_AwesomeLang642  */
static	ANTLR3_BITWORD FOLLOW_binOp_in_synpred30_AwesomeLang642_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000084FF0) };
static  ANTLR3_BITSET_LIST FOLLOW_binOp_in_synpred30_AwesomeLang642	= { FOLLOW_binOp_in_synpred30_AwesomeLang642_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_primaryExpr_in_synpred30_AwesomeLang644  */
static	ANTLR3_BITWORD FOLLOW_primaryExpr_in_synpred30_AwesomeLang644_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_primaryExpr_in_synpred30_AwesomeLang644	= { FOLLOW_primaryExpr_in_synpred30_AwesomeLang644_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_synpred33_AwesomeLang686  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_synpred33_AwesomeLang686_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_synpred33_AwesomeLang686	= { FOLLOW_IDENTIFIER_in_synpred33_AwesomeLang686_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_synpred33_AwesomeLang688  */
static	ANTLR3_BITWORD FOLLOW_14_in_synpred33_AwesomeLang688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008200) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_synpred33_AwesomeLang688	= { FOLLOW_14_in_synpred33_AwesomeLang688_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_in_synpred33_AwesomeLang690  */
static	ANTLR3_BITWORD FOLLOW_list_in_synpred33_AwesomeLang690_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_list_in_synpred33_AwesomeLang690	= { FOLLOW_list_in_synpred33_AwesomeLang690_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_synpred33_AwesomeLang692  */
static	ANTLR3_BITWORD FOLLOW_15_in_synpred33_AwesomeLang692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_synpred33_AwesomeLang692	= { FOLLOW_15_in_synpred33_AwesomeLang692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_synpred34_AwesomeLang700  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_synpred34_AwesomeLang700_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_synpred34_AwesomeLang700	= { FOLLOW_IDENTIFIER_in_synpred34_AwesomeLang700_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elseStatement_in_synpred47_AwesomeLang950  */
static	ANTLR3_BITWORD FOLLOW_elseStatement_in_synpred47_AwesomeLang950_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_elseStatement_in_synpred47_AwesomeLang950	= { FOLLOW_elseStatement_in_synpred47_AwesomeLang950_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_synpred50_AwesomeLang1024  */
static	ANTLR3_BITWORD FOLLOW_statement_in_synpred50_AwesomeLang1024_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_synpred50_AwesomeLang1024	= { FOLLOW_statement_in_synpred50_AwesomeLang1024_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_synpred51_AwesomeLang1024  */
static	ANTLR3_BITWORD FOLLOW_statement_in_synpred51_AwesomeLang1024_bits[]	= { ANTLR3_UINT64_LIT(0x0038420A00084FF2) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_synpred51_AwesomeLang1024	= { FOLLOW_statement_in_synpred51_AwesomeLang1024_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start list
 * AwesomeLang.g:37:1: list : ( item ( ',' item )* )? ;
 */
static void
list(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:38:5: ( ( item ( ',' item )* )? )
        // AwesomeLang.g:38:7: ( item ( ',' item )* )?
        {

            // AwesomeLang.g:38:7: ( item ( ',' item )* )?
            {
                int alt2=2;
                switch ( LA(1) )
                {
                    case IDENTIFIER:
                    	{
                    		alt2=1;
                    	}
                        break;
                }

                switch (alt2)
                {
            	case 1:
            	    // AwesomeLang.g:38:8: item ( ',' item )*
            	    {
            	        FOLLOWPUSH(FOLLOW_item_in_list299);
            	        item(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelistEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }



            	        // AwesomeLang.g:38:13: ( ',' item )*

            	        for (;;)
            	        {
            	            int alt1=2;
            	            switch ( LA(1) )
            	            {
            	            case 18:
            	            	{
            	            		alt1=1;
            	            	}
            	                break;

            	            }

            	            switch (alt1)
            	            {
            	        	case 1:
            	        	    // AwesomeLang.g:38:14: ',' item
            	        	    {
            	        	         MATCHT(18, &FOLLOW_18_in_list302);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelistEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_item_in_list304);
            	        	        item(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulelistEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop1;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop1: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }


    // This is where rules clean up and exit
    //
    goto rulelistEx; /* Prevent compiler warnings */
    rulelistEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end list */

/**
 * $ANTLR start item
 * AwesomeLang.g:41:1: item : IDENTIFIER ( 'of' typeRef )? ;
 */
static void
item(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:42:5: ( IDENTIFIER ( 'of' typeRef )? )
        // AwesomeLang.g:42:7: IDENTIFIER ( 'of' typeRef )?
        {
             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_item326);
            if  (HASEXCEPTION())
            {
                goto ruleitemEx;
            }
            if (HASFAILED())
            {
                return ;
            }



            // AwesomeLang.g:42:18: ( 'of' typeRef )?
            {
                int alt3=2;
                switch ( LA(1) )
                {
                    case 44:
                    	{
                    		alt3=1;
                    	}
                        break;
                }

                switch (alt3)
                {
            	case 1:
            	    // AwesomeLang.g:42:19: 'of' typeRef
            	    {
            	         MATCHT(44, &FOLLOW_44_in_item329);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleitemEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_typeRef_in_item331);
            	        typeRef(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleitemEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }


    // This is where rules clean up and exit
    //
    goto ruleitemEx; /* Prevent compiler warnings */
    ruleitemEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end item */

/**
 * $ANTLR start binOp
 * AwesomeLang.g:45:1: binOp : ( '+' | '-' | '*' | '/' | '^' | '%' | '<' | '<=' | '>' | '>=' | '==' | '!=' | 'and' | 'or' );
 */
static void
binOp(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:46:5: ( '+' | '-' | '*' | '/' | '^' | '%' | '<' | '<=' | '>' | '>=' | '==' | '!=' | 'and' | 'or' )
        // AwesomeLang.g:
        {
            if ( ((LA(1) >= 12) && (LA(1) <= 13)) || ((LA(1) >= 16) && (LA(1) <= 17)) || LA(1) == 19 || LA(1) == 21 || ((LA(1) >= 23) && (LA(1) <= 27)) || ((LA(1) >= 30) && (LA(1) <= 31)) || LA(1) == 45 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_binOp349;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_binOp349);
                goto rulebinOpEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto rulebinOpEx; /* Prevent compiler warnings */
    rulebinOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end binOp */

/**
 * $ANTLR start unOp
 * AwesomeLang.g:51:1: unOp : ( '-' | '!' );
 */
static void
unOp(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:52:5: ( '-' | '!' )
        // AwesomeLang.g:
        {
            if ( LA(1) == 11 || LA(1) == 19 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_unOp429;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_unOp429);
                goto ruleunOpEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleunOpEx; /* Prevent compiler warnings */
    ruleunOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end unOp */

/**
 * $ANTLR start typeRef
 * AwesomeLang.g:55:1: typeRef : ( builtin | IDENTIFIER | arrayType );
 */
static void
typeRef(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  AwesomeLang.g:56:5: ( builtin | IDENTIFIER | arrayType )

            ANTLR3_UINT32 alt4;

            alt4=3;

            switch ( LA(1) )
            {
            case 34:
            case 36:
            case 37:
            case 42:
            case 43:
            case 47:
            case 49:
            case 50:
            	{
            		switch ( LA(2) )
            		{
            		case EOF:
            		case BITS:
            		case BOOL:
            		case CHAR:
            		case DEC:
            		case HEX:
            		case IDENTIFIER:
            		case STRING:
            		case 11:
            		case 14:
            		case 15:
            		case 18:
            		case 19:
            		case 33:
            		case 35:
            		case 40:
            		case 41:
            		case 46:
            		case 51:
            		case 52:
            		case 53:
            			{
            				alt4=1;
            			}
            		    break;
            		case 32:
            			{
            				alt4=3;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 4;
            		    EXCEPTION->state        = 1;


            		    goto ruletypeRefEx;

            		}

            	}
                break;
            case IDENTIFIER:
            	{
            		switch ( LA(2) )
            		{
            		case EOF:
            		case BITS:
            		case BOOL:
            		case CHAR:
            		case DEC:
            		case HEX:
            		case IDENTIFIER:
            		case STRING:
            		case 11:
            		case 14:
            		case 15:
            		case 18:
            		case 19:
            		case 33:
            		case 35:
            		case 40:
            		case 41:
            		case 46:
            		case 51:
            		case 52:
            		case 53:
            			{
            				alt4=2;
            			}
            		    break;
            		case 32:
            			{
            				alt4=3;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 4;
            		    EXCEPTION->state        = 2;


            		    goto ruletypeRefEx;

            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto ruletypeRefEx;

            }

            switch (alt4)
            {
        	case 1:
        	    // AwesomeLang.g:56:7: builtin
        	    {
        	        FOLLOWPUSH(FOLLOW_builtin_in_typeRef453);
        	        builtin(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeRefEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // AwesomeLang.g:57:7: IDENTIFIER
        	    {
        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_typeRef461);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeRefEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // AwesomeLang.g:58:7: arrayType
        	    {
        	        FOLLOWPUSH(FOLLOW_arrayType_in_typeRef469);
        	        arrayType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeRefEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }


    // This is where rules clean up and exit
    //
    goto ruletypeRefEx; /* Prevent compiler warnings */
    ruletypeRefEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end typeRef */

/**
 * $ANTLR start builtin
 * AwesomeLang.g:61:1: builtin : ( 'bool' | 'byte' | 'int' | 'uint' | 'long' | 'ulong' | 'char' | 'string' );
 */
static void
builtin(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:62:5: ( 'bool' | 'byte' | 'int' | 'uint' | 'long' | 'ulong' | 'char' | 'string' )
        // AwesomeLang.g:
        {
            if ( LA(1) == 34 || ((LA(1) >= 36) && (LA(1) <= 37)) || ((LA(1) >= 42) && (LA(1) <= 43)) || LA(1) == 47 || ((LA(1) >= 49) && (LA(1) <= 50)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_builtin485;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_builtin485);
                goto rulebuiltinEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto rulebuiltinEx; /* Prevent compiler warnings */
    rulebuiltinEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end builtin */

/**
 * $ANTLR start arrayType
 * AwesomeLang.g:65:1: arrayType : ( builtin | IDENTIFIER ) 'array' '[' DEC ']' ;
 */
static void
arrayType(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:66:5: ( ( builtin | IDENTIFIER ) 'array' '[' DEC ']' )
        // AwesomeLang.g:66:7: ( builtin | IDENTIFIER ) 'array' '[' DEC ']'
        {

            // AwesomeLang.g:66:7: ( builtin | IDENTIFIER )
            {
                int alt5=2;
                switch ( LA(1) )
                {
                case 34:
                case 36:
                case 37:
                case 42:
                case 43:
                case 47:
                case 49:
                case 50:
                	{
                		alt5=1;
                	}
                    break;
                case IDENTIFIER:
                	{
                		alt5=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 5;
                    EXCEPTION->state        = 0;


                    goto rulearrayTypeEx;

                }

                switch (alt5)
                {
            	case 1:
            	    // AwesomeLang.g:66:8: builtin
            	    {
            	        FOLLOWPUSH(FOLLOW_builtin_in_arrayType534);
            	        builtin(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulearrayTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // AwesomeLang.g:66:18: IDENTIFIER
            	    {
            	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_arrayType538);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulearrayTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(32, &FOLLOW_32_in_arrayType541);
            if  (HASEXCEPTION())
            {
                goto rulearrayTypeEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(28, &FOLLOW_28_in_arrayType543);
            if  (HASEXCEPTION())
            {
                goto rulearrayTypeEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(DEC, &FOLLOW_DEC_in_arrayType545);
            if  (HASEXCEPTION())
            {
                goto rulearrayTypeEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(29, &FOLLOW_29_in_arrayType547);
            if  (HASEXCEPTION())
            {
                goto rulearrayTypeEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto rulearrayTypeEx; /* Prevent compiler warnings */
    rulearrayTypeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end arrayType */

/**
 * $ANTLR start funcSignature
 * AwesomeLang.g:69:1: funcSignature : IDENTIFIER '(' list ')' ( 'of' typeRef )? ;
 */
static void
funcSignature(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:70:5: ( IDENTIFIER '(' list ')' ( 'of' typeRef )? )
        // AwesomeLang.g:70:7: IDENTIFIER '(' list ')' ( 'of' typeRef )?
        {
             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_funcSignature565);
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(14, &FOLLOW_14_in_funcSignature567);
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_list_in_funcSignature569);
            list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(15, &FOLLOW_15_in_funcSignature571);
            if  (HASEXCEPTION())
            {
                goto rulefuncSignatureEx;
            }
            if (HASFAILED())
            {
                return ;
            }



            // AwesomeLang.g:70:31: ( 'of' typeRef )?
            {
                int alt6=2;
                switch ( LA(1) )
                {
                    case 44:
                    	{
                    		alt6=1;
                    	}
                        break;
                }

                switch (alt6)
                {
            	case 1:
            	    // AwesomeLang.g:70:32: 'of' typeRef
            	    {
            	         MATCHT(44, &FOLLOW_44_in_funcSignature574);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefuncSignatureEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_typeRef_in_funcSignature576);
            	        typeRef(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefuncSignatureEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }


    // This is where rules clean up and exit
    //
    goto rulefuncSignatureEx; /* Prevent compiler warnings */
    rulefuncSignatureEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end funcSignature */

/**
 * $ANTLR start sourceItem
 * AwesomeLang.g:73:1: sourceItem : funcDef ;
 */
static void
sourceItem(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:74:5: ( funcDef )
        // AwesomeLang.g:74:7: funcDef
        {
            FOLLOWPUSH(FOLLOW_funcDef_in_sourceItem596);
            funcDef(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesourceItemEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto rulesourceItemEx; /* Prevent compiler warnings */
    rulesourceItemEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sourceItem */

/**
 * $ANTLR start funcDef
 * AwesomeLang.g:77:1: funcDef : 'def' funcSignature ( statement )* 'end' ;
 */
static void
funcDef(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:78:5: ( 'def' funcSignature ( statement )* 'end' )
        // AwesomeLang.g:78:7: 'def' funcSignature ( statement )* 'end'
        {
             MATCHT(38, &FOLLOW_38_in_funcDef614);
            if  (HASEXCEPTION())
            {
                goto rulefuncDefEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_funcSignature_in_funcDef616);
            funcSignature(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefuncDefEx;
            }
            if (HASFAILED())
            {
                return ;
            }



            // AwesomeLang.g:78:27: ( statement )*

            for (;;)
            {
                int alt7=2;
                switch ( LA(1) )
                {
                case BITS:
                case BOOL:
                case CHAR:
                case DEC:
                case HEX:
                case IDENTIFIER:
                case STRING:
                case 11:
                case 14:
                case 19:
                case 33:
                case 35:
                case 41:
                case 46:
                case 51:
                case 52:
                case 53:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7)
                {
            	case 1:
            	    // AwesomeLang.g:78:27: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_funcDef618);
            	        statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefuncDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


             MATCHT(40, &FOLLOW_40_in_funcDef621);
            if  (HASEXCEPTION())
            {
                goto rulefuncDefEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto rulefuncDefEx; /* Prevent compiler warnings */
    rulefuncDefEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end funcDef */

/**
 * $ANTLR start expr
 * AwesomeLang.g:81:1: expr : primaryExpr ( binOp primaryExpr )* ;
 */
static void
expr(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:82:5: ( primaryExpr ( binOp primaryExpr )* )
        // AwesomeLang.g:82:7: primaryExpr ( binOp primaryExpr )*
        {
            FOLLOWPUSH(FOLLOW_primaryExpr_in_expr639);
            primaryExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexprEx;
            }
            if (HASFAILED())
            {
                return ;
            }



            // AwesomeLang.g:82:19: ( binOp primaryExpr )*

            for (;;)
            {
                int alt8=2;
                switch ( LA(1) )
                {
                case 19:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA8_11 = LA(2);
                		    if ( (synpred30_AwesomeLang(ctx)))
                		    {
                		        alt8=1;
                		    }

                		}
                	}
                    break;
                case 12:
                case 13:
                case 16:
                case 17:
                case 21:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 30:
                case 31:
                case 45:
                	{
                		alt8=1;
                	}
                    break;

                }

                switch (alt8)
                {
            	case 1:
            	    // AwesomeLang.g:82:20: binOp primaryExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_binOp_in_expr642);
            	        binOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_primaryExpr_in_expr644);
            	        primaryExpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end expr */

/**
 * $ANTLR start primaryExpr
 * AwesomeLang.g:85:1: primaryExpr : ( unOp primaryExpr | '(' expr ')' | IDENTIFIER '(' list ')' | IDENTIFIER | literal );
 */
static void
primaryExpr(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  AwesomeLang.g:86:5: ( unOp primaryExpr | '(' expr ')' | IDENTIFIER '(' list ')' | IDENTIFIER | literal )

            ANTLR3_UINT32 alt9;

            alt9=5;

            switch ( LA(1) )
            {
            case 11:
            case 19:
            	{
            		alt9=1;
            	}
                break;
            case 14:
            	{
            		alt9=2;
            	}
                break;
            case IDENTIFIER:
            	{
            		switch ( LA(2) )
            		{
            		case 14:
            			{
            				switch ( LA(3) )
            				{
            				case IDENTIFIER:
            					{
            						switch ( LA(4) )
            						{
            						case 12:
            						case 13:
            						case 14:
            						case 16:
            						case 17:
            						case 19:
            						case 21:
            						case 23:
            						case 24:
            						case 25:
            						case 26:
            						case 27:
            						case 30:
            						case 31:
            						case 45:
            							{
            								alt9=4;
            							}
            						    break;
            						case 18:
            						case 44:
            							{
            								alt9=3;
            							}
            						    break;
            						case 15:
            							{

            								{
            								    int LA9_9 = LA(5);
            								    if ( (synpred33_AwesomeLang(ctx)))
            								    {
            								        alt9=3;
            								    }
            								    else if ( (synpred34_AwesomeLang(ctx)))
            								    {
            								        alt9=4;
            								    }
            								    else
            								    {
            								        if (BACKTRACKING>0)
            								        {
            								            FAILEDFLAG = ANTLR3_TRUE;
            								            return ;
            								        }


            								        CONSTRUCTEX();
            								        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								        EXCEPTION->message      = (void *)"";
            								        EXCEPTION->decisionNum  = 9;
            								        EXCEPTION->state        = 9;


            								        goto ruleprimaryExprEx;

            								    }
            								}
            							}
            						    break;

            						default:
            						    if (BACKTRACKING>0)
            						    {
            						        FAILEDFLAG = ANTLR3_TRUE;
            						        return ;
            						    }

            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 7;


            						    goto ruleprimaryExprEx;

            						}

            					}
            				    break;
            				case 15:
            					{
            						alt9=3;
            					}
            				    break;
            				case BITS:
            				case BOOL:
            				case CHAR:
            				case DEC:
            				case HEX:
            				case STRING:
            				case 11:
            				case 14:
            				case 19:
            					{
            						alt9=4;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ;
            				    }

            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 9;
            				    EXCEPTION->state        = 5;


            				    goto ruleprimaryExprEx;

            				}

            			}
            		    break;
            		case EOF:
            		case BITS:
            		case BOOL:
            		case CHAR:
            		case DEC:
            		case HEX:
            		case IDENTIFIER:
            		case STRING:
            		case 11:
            		case 12:
            		case 13:
            		case 15:
            		case 16:
            		case 17:
            		case 18:
            		case 19:
            		case 20:
            		case 21:
            		case 22:
            		case 23:
            		case 24:
            		case 25:
            		case 26:
            		case 27:
            		case 28:
            		case 29:
            		case 30:
            		case 31:
            		case 33:
            		case 35:
            		case 40:
            		case 41:
            		case 45:
            		case 46:
            		case 48:
            		case 51:
            		case 52:
            		case 53:
            			{
            				alt9=4;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 9;
            		    EXCEPTION->state        = 3;


            		    goto ruleprimaryExprEx;

            		}

            	}
                break;
            case BITS:
            case BOOL:
            case CHAR:
            case DEC:
            case HEX:
            case STRING:
            	{
            		alt9=5;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 9;
                EXCEPTION->state        = 0;


                goto ruleprimaryExprEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // AwesomeLang.g:86:7: unOp primaryExpr
        	    {
        	        FOLLOWPUSH(FOLLOW_unOp_in_primaryExpr664);
        	        unOp(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_primaryExpr_in_primaryExpr666);
        	        primaryExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // AwesomeLang.g:87:7: '(' expr ')'
        	    {
        	         MATCHT(14, &FOLLOW_14_in_primaryExpr674);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_expr_in_primaryExpr676);
        	        expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(15, &FOLLOW_15_in_primaryExpr678);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // AwesomeLang.g:88:7: IDENTIFIER '(' list ')'
        	    {
        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_primaryExpr686);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(14, &FOLLOW_14_in_primaryExpr688);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_list_in_primaryExpr690);
        	        list(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(15, &FOLLOW_15_in_primaryExpr692);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // AwesomeLang.g:89:7: IDENTIFIER
        	    {
        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_primaryExpr700);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // AwesomeLang.g:90:7: literal
        	    {
        	        FOLLOWPUSH(FOLLOW_literal_in_primaryExpr708);
        	        literal(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimaryExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }


    // This is where rules clean up and exit
    //
    goto ruleprimaryExprEx; /* Prevent compiler warnings */
    ruleprimaryExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end primaryExpr */

/**
 * $ANTLR start sliceExpr
 * AwesomeLang.g:94:1: sliceExpr : primaryExpr '[' rangeList ']' ;
 */
static void
sliceExpr(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:95:5: ( primaryExpr '[' rangeList ']' )
        // AwesomeLang.g:95:7: primaryExpr '[' rangeList ']'
        {
            FOLLOWPUSH(FOLLOW_primaryExpr_in_sliceExpr728);
            primaryExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesliceExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(28, &FOLLOW_28_in_sliceExpr730);
            if  (HASEXCEPTION())
            {
                goto rulesliceExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_rangeList_in_sliceExpr732);
            rangeList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesliceExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(29, &FOLLOW_29_in_sliceExpr734);
            if  (HASEXCEPTION())
            {
                goto rulesliceExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto rulesliceExprEx; /* Prevent compiler warnings */
    rulesliceExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sliceExpr */

/**
 * $ANTLR start callExpr
 * AwesomeLang.g:98:1: callExpr : IDENTIFIER '(' list ')' ;
 */
static void
callExpr(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:99:5: ( IDENTIFIER '(' list ')' )
        // AwesomeLang.g:99:7: IDENTIFIER '(' list ')'
        {
             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_callExpr751);
            if  (HASEXCEPTION())
            {
                goto rulecallExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(14, &FOLLOW_14_in_callExpr753);
            if  (HASEXCEPTION())
            {
                goto rulecallExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_list_in_callExpr755);
            list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecallExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(15, &FOLLOW_15_in_callExpr757);
            if  (HASEXCEPTION())
            {
                goto rulecallExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto rulecallExprEx; /* Prevent compiler warnings */
    rulecallExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end callExpr */

/**
 * $ANTLR start literal
 * AwesomeLang.g:102:1: literal : ( BOOL | STRING | CHAR | HEX | BITS | DEC );
 */
static void
literal(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:103:5: ( BOOL | STRING | CHAR | HEX | BITS | DEC )
        // AwesomeLang.g:
        {
            if ( ((LA(1) >= BITS) && (LA(1) <= HEX)) || LA(1) == STRING )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_literal773;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_literal773);
                goto ruleliteralEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleliteralEx; /* Prevent compiler warnings */
    ruleliteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end literal */

/**
 * $ANTLR start range
 * AwesomeLang.g:111:1: range : expr ( '..' expr )? ;
 */
static void
range(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:112:5: ( expr ( '..' expr )? )
        // AwesomeLang.g:112:7: expr ( '..' expr )?
        {
            FOLLOWPUSH(FOLLOW_expr_in_range833);
            expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerangeEx;
            }
            if (HASFAILED())
            {
                return ;
            }



            // AwesomeLang.g:112:12: ( '..' expr )?
            {
                int alt10=2;
                switch ( LA(1) )
                {
                    case 20:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10)
                {
            	case 1:
            	    // AwesomeLang.g:112:13: '..' expr
            	    {
            	         MATCHT(20, &FOLLOW_20_in_range836);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerangeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_expr_in_range838);
            	        expr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerangeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }


    // This is where rules clean up and exit
    //
    goto rulerangeEx; /* Prevent compiler warnings */
    rulerangeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end range */

/**
 * $ANTLR start rangeList
 * AwesomeLang.g:115:1: rangeList : range ( ',' range )* ;
 */
static void
rangeList(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:116:5: ( range ( ',' range )* )
        // AwesomeLang.g:116:7: range ( ',' range )*
        {
            FOLLOWPUSH(FOLLOW_range_in_rangeList858);
            range(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerangeListEx;
            }
            if (HASFAILED())
            {
                return ;
            }



            // AwesomeLang.g:116:13: ( ',' range )*

            for (;;)
            {
                int alt11=2;
                switch ( LA(1) )
                {
                case 18:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11)
                {
            	case 1:
            	    // AwesomeLang.g:116:14: ',' range
            	    {
            	         MATCHT(18, &FOLLOW_18_in_rangeList861);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerangeListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_range_in_rangeList863);
            	        range(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerangeListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */


        }

    }


    // This is where rules clean up and exit
    //
    goto rulerangeListEx; /* Prevent compiler warnings */
    rulerangeListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end rangeList */

/**
 * $ANTLR start statement
 * AwesomeLang.g:119:1: statement : ( ifStatement | loopStatement | repeatStatement | breakStatement | expressionStatement | blockStatement );
 */
static void
statement(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  AwesomeLang.g:120:5: ( ifStatement | loopStatement | repeatStatement | breakStatement | expressionStatement | blockStatement )

            ANTLR3_UINT32 alt12;

            alt12=6;

            switch ( LA(1) )
            {
            case 41:
            	{
            		alt12=1;
            	}
                break;
            case 51:
            case 52:
            	{
            		alt12=2;
            	}
                break;
            case 46:
            	{
            		alt12=3;
            	}
                break;
            case 35:
            	{
            		alt12=4;
            	}
                break;
            case BITS:
            case BOOL:
            case CHAR:
            case DEC:
            case HEX:
            case IDENTIFIER:
            case STRING:
            case 11:
            case 14:
            case 19:
            	{
            		alt12=5;
            	}
                break;
            case 33:
            case 53:
            	{
            		alt12=6;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 12;
                EXCEPTION->state        = 0;


                goto rulestatementEx;

            }

            switch (alt12)
            {
        	case 1:
        	    // AwesomeLang.g:120:7: ifStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_ifStatement_in_statement883);
        	        ifStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // AwesomeLang.g:121:7: loopStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_loopStatement_in_statement891);
        	        loopStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // AwesomeLang.g:122:7: repeatStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_repeatStatement_in_statement899);
        	        repeatStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // AwesomeLang.g:123:7: breakStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_breakStatement_in_statement907);
        	        breakStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // AwesomeLang.g:124:7: expressionStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_expressionStatement_in_statement915);
        	        expressionStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // AwesomeLang.g:125:7: blockStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_blockStatement_in_statement923);
        	        blockStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }


    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end statement */

/**
 * $ANTLR start ifStatement
 * AwesomeLang.g:128:1: ifStatement : 'if' expr 'then' statement ( elseStatement )? ;
 */
static void
ifStatement(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:129:5: ( 'if' expr 'then' statement ( elseStatement )? )
        // AwesomeLang.g:129:7: 'if' expr 'then' statement ( elseStatement )?
        {
             MATCHT(41, &FOLLOW_41_in_ifStatement941);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_expr_in_ifStatement943);
            expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(48, &FOLLOW_48_in_ifStatement945);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_statement_in_ifStatement947);
            statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }



            // AwesomeLang.g:129:34: ( elseStatement )?
            {
                int alt13=2;
                switch ( LA(1) )
                {
                    case 39:
                    	{
                    		{
                    		    int LA13_1 = LA(2);
                    		    if ( (synpred47_AwesomeLang(ctx)))
                    		    {
                    		        alt13=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt13)
                {
            	case 1:
            	    // AwesomeLang.g:129:35: elseStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_elseStatement_in_ifStatement950);
            	        elseStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }


    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end ifStatement */

/**
 * $ANTLR start elseStatement
 * AwesomeLang.g:132:1: elseStatement : 'else' statement ;
 */
static void
elseStatement(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:133:5: ( 'else' statement )
        // AwesomeLang.g:133:7: 'else' statement
        {
             MATCHT(39, &FOLLOW_39_in_elseStatement970);
            if  (HASEXCEPTION())
            {
                goto ruleelseStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_statement_in_elseStatement972);
            statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleelseStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleelseStatementEx; /* Prevent compiler warnings */
    ruleelseStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end elseStatement */

/**
 * $ANTLR start loopStatement
 * AwesomeLang.g:136:1: loopStatement : ( 'while' | 'until' ) expr ( statement )* 'end' ;
 */
static void
loopStatement(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:137:5: ( ( 'while' | 'until' ) expr ( statement )* 'end' )
        // AwesomeLang.g:137:7: ( 'while' | 'until' ) expr ( statement )* 'end'
        {
            if ( ((LA(1) >= 51) && (LA(1) <= 52)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_loopStatement990;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_loopStatement990);
                goto ruleloopStatementEx;
            }


            FOLLOWPUSH(FOLLOW_expr_in_loopStatement998);
            expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }



            // AwesomeLang.g:137:32: ( statement )*

            for (;;)
            {
                int alt14=2;
                switch ( LA(1) )
                {
                case BITS:
                case BOOL:
                case CHAR:
                case DEC:
                case HEX:
                case IDENTIFIER:
                case STRING:
                case 11:
                case 14:
                case 19:
                case 33:
                case 35:
                case 41:
                case 46:
                case 51:
                case 52:
                case 53:
                	{
                		alt14=1;
                	}
                    break;

                }

                switch (alt14)
                {
            	case 1:
            	    // AwesomeLang.g:137:32: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_loopStatement1000);
            	        statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleloopStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */


             MATCHT(40, &FOLLOW_40_in_loopStatement1003);
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleloopStatementEx; /* Prevent compiler warnings */
    ruleloopStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end loopStatement */

/**
 * $ANTLR start repeatStatement
 * AwesomeLang.g:140:1: repeatStatement : 'repeat' ( ( statement )+ )? ( 'while' | 'until' ) expr ';' ;
 */
static void
repeatStatement(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:141:5: ( 'repeat' ( ( statement )+ )? ( 'while' | 'until' ) expr ';' )
        // AwesomeLang.g:141:7: 'repeat' ( ( statement )+ )? ( 'while' | 'until' ) expr ';'
        {
             MATCHT(46, &FOLLOW_46_in_repeatStatement1021);
            if  (HASEXCEPTION())
            {
                goto rulerepeatStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }



            // AwesomeLang.g:141:16: ( ( statement )+ )?
            {
                int alt16=2;
                switch ( LA(1) )
                {
                    case BITS:
                    case BOOL:
                    case CHAR:
                    case DEC:
                    case HEX:
                    case IDENTIFIER:
                    case STRING:
                    case 11:
                    case 14:
                    case 19:
                    case 33:
                    case 35:
                    case 41:
                    case 46:
                    case 53:
                    	{
                    		alt16=1;
                    	}
                        break;
                    case 51:
                    case 52:
                    	{
                    		{
                    		    int LA16_2 = LA(2);
                    		    if ( (synpred51_AwesomeLang(ctx)))
                    		    {
                    		        alt16=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt16)
                {
            	case 1:
            	    // AwesomeLang.g:141:17: ( statement )+
            	    {
            	        // AwesomeLang.g:141:17: ( statement )+
            	        {
            	            int cnt15=0;

            	            for (;;)
            	            {
            	                int alt15=2;
            	        	switch ( LA(1) )
            	        	{
            	        	case 51:
            	        	case 52:
            	        		{
            	        			{
            	        			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        			    */
            	        			    int LA15_1 = LA(2);
            	        			    if ( (synpred50_AwesomeLang(ctx)))
            	        			    {
            	        			        alt15=1;
            	        			    }

            	        			}
            	        		}
            	        	    break;
            	        	case BITS:
            	        	case BOOL:
            	        	case CHAR:
            	        	case DEC:
            	        	case HEX:
            	        	case IDENTIFIER:
            	        	case STRING:
            	        	case 11:
            	        	case 14:
            	        	case 19:
            	        	case 33:
            	        	case 35:
            	        	case 41:
            	        	case 46:
            	        	case 53:
            	        		{
            	        			alt15=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt15)
            	        	{
            	        	    case 1:
            	        	        // AwesomeLang.g:141:17: statement
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_statement_in_repeatStatement1024);
            	        	            statement(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto rulerepeatStatementEx;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return ;
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt15 >= 1 )
            	        		{
            	        		    goto loop15;
            	        		}
            	        		if (BACKTRACKING>0)
            	        		{
            	        		    FAILEDFLAG = ANTLR3_TRUE;
            	        		    return ;
            	        		}

            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto rulerepeatStatementEx;
            	        	}
            	        	cnt15++;
            	            }
            	            loop15: ;	/* Jump to here if this rule does not match */
            	        }

            	    }
            	    break;

                }
            }

            if ( ((LA(1) >= 51) && (LA(1) <= 52)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_repeatStatement1029;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_repeatStatement1029);
                goto rulerepeatStatementEx;
            }


            FOLLOWPUSH(FOLLOW_expr_in_repeatStatement1037);
            expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerepeatStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(22, &FOLLOW_22_in_repeatStatement1039);
            if  (HASEXCEPTION())
            {
                goto rulerepeatStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto rulerepeatStatementEx; /* Prevent compiler warnings */
    rulerepeatStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end repeatStatement */

/**
 * $ANTLR start breakStatement
 * AwesomeLang.g:144:1: breakStatement : 'break' ';' ;
 */
static void
breakStatement(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:145:5: ( 'break' ';' )
        // AwesomeLang.g:145:7: 'break' ';'
        {
             MATCHT(35, &FOLLOW_35_in_breakStatement1057);
            if  (HASEXCEPTION())
            {
                goto rulebreakStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(22, &FOLLOW_22_in_breakStatement1059);
            if  (HASEXCEPTION())
            {
                goto rulebreakStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto rulebreakStatementEx; /* Prevent compiler warnings */
    rulebreakStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end breakStatement */

/**
 * $ANTLR start expressionStatement
 * AwesomeLang.g:148:1: expressionStatement : expr ';' ;
 */
static void
expressionStatement(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:149:5: ( expr ';' )
        // AwesomeLang.g:149:7: expr ';'
        {
            FOLLOWPUSH(FOLLOW_expr_in_expressionStatement1077);
            expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(22, &FOLLOW_22_in_expressionStatement1079);
            if  (HASEXCEPTION())
            {
                goto ruleexpressionStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleexpressionStatementEx; /* Prevent compiler warnings */
    ruleexpressionStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end expressionStatement */

/**
 * $ANTLR start blockStatement
 * AwesomeLang.g:152:1: blockStatement : ( 'begin' | '{' ) ( statement | sourceItem )* ( 'end' | '}' ) ;
 */
static void
blockStatement(pAwesomeLangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // AwesomeLang.g:153:5: ( ( 'begin' | '{' ) ( statement | sourceItem )* ( 'end' | '}' ) )
        // AwesomeLang.g:153:7: ( 'begin' | '{' ) ( statement | sourceItem )* ( 'end' | '}' )
        {
            if ( LA(1) == 33 || LA(1) == 53 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_blockStatement1097;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_blockStatement1097);
                goto ruleblockStatementEx;
            }



            // AwesomeLang.g:153:23: ( statement | sourceItem )*

            for (;;)
            {
                int alt17=3;
                switch ( LA(1) )
                {
                case BITS:
                case BOOL:
                case CHAR:
                case DEC:
                case HEX:
                case IDENTIFIER:
                case STRING:
                case 11:
                case 14:
                case 19:
                case 33:
                case 35:
                case 41:
                case 46:
                case 51:
                case 52:
                case 53:
                	{
                		alt17=1;
                	}
                    break;
                case 38:
                	{
                		alt17=2;
                	}
                    break;

                }

                switch (alt17)
                {
            	case 1:
            	    // AwesomeLang.g:153:24: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_blockStatement1106);
            	        statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleblockStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // AwesomeLang.g:153:36: sourceItem
            	    {
            	        FOLLOWPUSH(FOLLOW_sourceItem_in_blockStatement1110);
            	        sourceItem(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleblockStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop17;	/* break out of the loop */
            	    break;
                }
            }
            loop17: ; /* Jump out to here if this rule does not match */


            if ( LA(1) == 40 || LA(1) == 54 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_blockStatement1114;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_blockStatement1114);
                goto ruleblockStatementEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleblockStatementEx; /* Prevent compiler warnings */
    ruleblockStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end blockStatement */

// $ANTLR start synpred30_AwesomeLang
static void synpred30_AwesomeLang_fragment(pAwesomeLangParser ctx )
{
    // AwesomeLang.g:82:20: ( binOp primaryExpr )
    // AwesomeLang.g:82:20: binOp primaryExpr
    {
        FOLLOWPUSH(FOLLOW_binOp_in_synpred30_AwesomeLang642);
        binOp(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred30_AwesomeLangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        FOLLOWPUSH(FOLLOW_primaryExpr_in_synpred30_AwesomeLang644);
        primaryExpr(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred30_AwesomeLangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }


// This is where rules clean up and exit
//
goto rulesynpred30_AwesomeLangEx; /* Prevent compiler warnings */
rulesynpred30_AwesomeLangEx: ;

}
// $ANTLR end synpred30_AwesomeLang

// $ANTLR start synpred33_AwesomeLang
static void synpred33_AwesomeLang_fragment(pAwesomeLangParser ctx )
{
    // AwesomeLang.g:88:7: ( IDENTIFIER '(' list ')' )
    // AwesomeLang.g:88:7: IDENTIFIER '(' list ')'
    {
         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_synpred33_AwesomeLang686);
        if  (HASEXCEPTION())
        {
            goto rulesynpred33_AwesomeLangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


         MATCHT(14, &FOLLOW_14_in_synpred33_AwesomeLang688);
        if  (HASEXCEPTION())
        {
            goto rulesynpred33_AwesomeLangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        FOLLOWPUSH(FOLLOW_list_in_synpred33_AwesomeLang690);
        list(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred33_AwesomeLangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


         MATCHT(15, &FOLLOW_15_in_synpred33_AwesomeLang692);
        if  (HASEXCEPTION())
        {
            goto rulesynpred33_AwesomeLangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }


// This is where rules clean up and exit
//
goto rulesynpred33_AwesomeLangEx; /* Prevent compiler warnings */
rulesynpred33_AwesomeLangEx: ;

}
// $ANTLR end synpred33_AwesomeLang

// $ANTLR start synpred34_AwesomeLang
static void synpred34_AwesomeLang_fragment(pAwesomeLangParser ctx )
{
    // AwesomeLang.g:89:7: ( IDENTIFIER )
    // AwesomeLang.g:89:7: IDENTIFIER
    {
         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_synpred34_AwesomeLang700);
        if  (HASEXCEPTION())
        {
            goto rulesynpred34_AwesomeLangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }


// This is where rules clean up and exit
//
goto rulesynpred34_AwesomeLangEx; /* Prevent compiler warnings */
rulesynpred34_AwesomeLangEx: ;

}
// $ANTLR end synpred34_AwesomeLang

// $ANTLR start synpred47_AwesomeLang
static void synpred47_AwesomeLang_fragment(pAwesomeLangParser ctx )
{
    // AwesomeLang.g:129:35: ( elseStatement )
    // AwesomeLang.g:129:35: elseStatement
    {
        FOLLOWPUSH(FOLLOW_elseStatement_in_synpred47_AwesomeLang950);
        elseStatement(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred47_AwesomeLangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }


// This is where rules clean up and exit
//
goto rulesynpred47_AwesomeLangEx; /* Prevent compiler warnings */
rulesynpred47_AwesomeLangEx: ;

}
// $ANTLR end synpred47_AwesomeLang

// $ANTLR start synpred50_AwesomeLang
static void synpred50_AwesomeLang_fragment(pAwesomeLangParser ctx )
{
    // AwesomeLang.g:141:17: ( statement )
    // AwesomeLang.g:141:17: statement
    {
        FOLLOWPUSH(FOLLOW_statement_in_synpred50_AwesomeLang1024);
        statement(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred50_AwesomeLangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }


// This is where rules clean up and exit
//
goto rulesynpred50_AwesomeLangEx; /* Prevent compiler warnings */
rulesynpred50_AwesomeLangEx: ;

}
// $ANTLR end synpred50_AwesomeLang

// $ANTLR start synpred51_AwesomeLang
static void synpred51_AwesomeLang_fragment(pAwesomeLangParser ctx )
{
    // AwesomeLang.g:141:17: ( ( statement )+ )
    // AwesomeLang.g:141:17: ( statement )+
    {
        // AwesomeLang.g:141:17: ( statement )+
        {
            int cnt19=0;

            for (;;)
            {
                int alt19=2;
        	switch ( LA(1) )
        	{
        	case BITS:
        	case BOOL:
        	case CHAR:
        	case DEC:
        	case HEX:
        	case IDENTIFIER:
        	case STRING:
        	case 11:
        	case 14:
        	case 19:
        	case 33:
        	case 35:
        	case 41:
        	case 46:
        	case 51:
        	case 52:
        	case 53:
        		{
        			alt19=1;
        		}
        	    break;

        	}

        	switch (alt19)
        	{
        	    case 1:
        	        // AwesomeLang.g:141:17: statement
        	        {
        	            FOLLOWPUSH(FOLLOW_statement_in_synpred51_AwesomeLang1024);
        	            statement(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesynpred51_AwesomeLangEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt19 >= 1 )
        		{
        		    goto loop19;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto rulesynpred51_AwesomeLangEx;
        	}
        	cnt19++;
            }
            loop19: ;	/* Jump to here if this rule does not match */
        }

    }


// This is where rules clean up and exit
//
goto rulesynpred51_AwesomeLangEx; /* Prevent compiler warnings */
rulesynpred51_AwesomeLangEx: ;

}
// $ANTLR end synpred51_AwesomeLang
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred51_AwesomeLang(pAwesomeLangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred51_AwesomeLang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred33_AwesomeLang(pAwesomeLangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred33_AwesomeLang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred47_AwesomeLang(pAwesomeLangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred47_AwesomeLang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred50_AwesomeLang(pAwesomeLangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred50_AwesomeLang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred30_AwesomeLang(pAwesomeLangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred30_AwesomeLang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred34_AwesomeLang(pAwesomeLangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred34_AwesomeLang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
